/**
 * IoT Repository Manager
 * Specialized management for IoT/embedded systems repositories
 */
const RepositoryManager = require('../core/RepositoryManager');
const fs = require('fs').promises;
const path = require('path');

class IoTManager extends RepositoryManager {
    constructor(config = {}) {
        super(config);
        this.iotTypes = [
            'iot-firmware',
            'iot-server',
            'iot-documentation',
            'iot-infrastructure',
        ];
    }

    /**
     * Detect if repository is IoT-related
     */
    async detectIoTRepository() {
        try {
            const packageData = await this.getPackageMetadata();
            if (packageData) {
                const repoType = this.detectRepositoryType(packageData);
                return this.iotTypes.includes(repoType);
            }

            // Check for IoT-specific files if no package.json
            const iotFiles = await this.checkIoTFiles();
            return iotFiles.length > 0;
        } catch (error) {
            console.error('Error detecting IoT repository:', error.message);
            return false;
        }
    }

    /**
     * Check for IoT-specific files
     */
    async checkIoTFiles() {
        const iotFiles = [];
        const filesToCheck = [
            'platformio.ini',
            'arduino.ino',
            'src/main.cpp',
            'src/main.c',
            'lib/',
            'include/',
            'CMakeLists.txt',
            'Makefile',
            'esp32/',
            'esp8266/',
            'firmware/',
            'hardware/',
            'pcb/',
            'schematics/',
            'mqtt.conf',
            'sensor-config.json',
            'lora-config.h',
            'wifi-config.h',
        ];

        for (const file of filesToCheck) {
            try {
                const filePath = path.join(process.cwd(), file);
                await fs.access(filePath);
                iotFiles.push(file);
            } catch {
                // File doesn't exist, continue
            }
        }

        return iotFiles;
    }

    /**
     * Audit IoT repository for compliance
     */
    async auditIoTCompliance() {
        console.log('üîç Starting IoT repository compliance audit...\n');

        const results = {
            isIoT: false,
            repositoryType: 'general',
            score: 0,
            maxScore: 100,
            findings: [],
            recommendations: [],
            iotFiles: [],
            securityIssues: [],
            documentationIssues: [],
        };

        // Detect if this is an IoT repository
        results.isIoT = await this.detectIoTRepository();

        if (!results.isIoT) {
            console.log('‚ÑπÔ∏è  This does not appear to be an IoT repository');
            return results;
        }

        console.log('‚úÖ IoT repository detected\n');

        // Get repository type
        const packageData = await this.getPackageMetadata();
        if (packageData) {
            results.repositoryType = this.detectRepositoryType(packageData);
        }

        // Check IoT-specific files
        results.iotFiles = await this.checkIoTFiles();

        // Run type-specific audits
        await this.auditByType(results);

        // Calculate score
        results.score = this.calculateIoTScore(results);

        this.displayIoTResults(results);
        return results;
    }

    /**
     * Run audits based on IoT repository type
     */
    async auditByType(results) {
        switch (results.repositoryType) {
            case 'iot-firmware':
                await this.auditFirmware(results);
                break;
            case 'iot-server':
                await this.auditIoTServer(results);
                break;
            case 'iot-documentation':
                await this.auditIoTDocumentation(results);
                break;
            case 'iot-infrastructure':
                await this.auditIoTInfrastructure(results);
                break;
            default:
                await this.auditGeneralIoT(results);
        }
    }

    /**
     * Audit firmware-specific requirements
     */
    async auditFirmware(results) {
        const checks = [
            {
                file: 'platformio.ini',
                weight: 15,
                name: 'PlatformIO configuration',
            },
            { file: 'src/main.cpp', weight: 10, name: 'Main firmware file' },
            { file: 'include/', weight: 8, name: 'Header files directory' },
            { file: 'lib/', weight: 5, name: 'Libraries directory' },
            { file: 'README.md', weight: 10, name: 'Documentation' },
            { file: 'LICENSE', weight: 5, name: 'License file' },
            { file: '.gitignore', weight: 3, name: 'Git ignore file' },
        ];

        for (const check of checks) {
            if (
                results.iotFiles.includes(check.file) ||
                (await this.fileExists(check.file))
            ) {
                results.score += check.weight;
                results.findings.push(`‚úÖ ${check.name} found`);
            } else {
                results.recommendations.push(
                    `Add ${check.name} (${check.file})`
                );
            }
        }

        // Check for security best practices
        await this.auditFirmwareSecurity(results);
    }

    /**
     * Audit IoT server requirements
     */
    async auditIoTServer(results) {
        const checks = [
            {
                file: 'requirements.txt',
                weight: 10,
                name: 'Python dependencies',
            },
            { file: 'package.json', weight: 10, name: 'Node.js dependencies' },
            {
                file: 'docker-compose.yml',
                weight: 15,
                name: 'Docker deployment',
            },
            { file: 'Dockerfile', weight: 10, name: 'Container configuration' },
            { file: 'config/', weight: 8, name: 'Configuration directory' },
            { file: 'tests/', weight: 12, name: 'Test suite' },
            { file: '.env.example', weight: 8, name: 'Environment template' },
        ];

        for (const check of checks) {
            if (await this.fileExists(check.file)) {
                results.score += check.weight;
                results.findings.push(`‚úÖ ${check.name} found`);
            } else {
                results.recommendations.push(
                    `Add ${check.name} (${check.file})`
                );
            }
        }

        // Check for MQTT/API documentation
        await this.auditServerDocumentation(results);
    }

    /**
     * Audit IoT documentation requirements
     */
    async auditIoTDocumentation(results) {
        const checks = [
            { file: 'README.md', weight: 20, name: 'Main documentation' },
            { file: 'docs/', weight: 15, name: 'Documentation directory' },
            { file: 'API.md', weight: 10, name: 'API documentation' },
            { file: 'HARDWARE.md', weight: 10, name: 'Hardware documentation' },
            { file: 'INSTALLATION.md', weight: 8, name: 'Installation guide' },
            {
                file: 'TROUBLESHOOTING.md',
                weight: 7,
                name: 'Troubleshooting guide',
            },
            { file: 'examples/', weight: 10, name: 'Examples directory' },
        ];

        for (const check of checks) {
            if (await this.fileExists(check.file)) {
                results.score += check.weight;
                results.findings.push(`‚úÖ ${check.name} found`);
            } else {
                results.recommendations.push(
                    `Add ${check.name} (${check.file})`
                );
            }
        }
    }

    /**
     * Audit IoT infrastructure requirements
     */
    async auditIoTInfrastructure(results) {
        const checks = [
            {
                file: 'docker-compose.yml',
                weight: 20,
                name: 'Docker Compose configuration',
            },
            { file: 'Dockerfile', weight: 15, name: 'Container definitions' },
            { file: 'k8s/', weight: 10, name: 'Kubernetes manifests' },
            { file: 'terraform/', weight: 10, name: 'Infrastructure as Code' },
            { file: 'scripts/', weight: 8, name: 'Deployment scripts' },
            {
                file: 'monitoring/',
                weight: 12,
                name: 'Monitoring configuration',
            },
            { file: 'security/', weight: 10, name: 'Security policies' },
        ];

        for (const check of checks) {
            if (await this.fileExists(check.file)) {
                results.score += check.weight;
                results.findings.push(`‚úÖ ${check.name} found`);
            } else {
                results.recommendations.push(
                    `Add ${check.name} (${check.file})`
                );
            }
        }
    }

    /**
     * Audit general IoT requirements
     */
    async auditGeneralIoT(results) {
        const checks = [
            { file: 'README.md', weight: 25, name: 'Documentation' },
            { file: 'LICENSE', weight: 10, name: 'License file' },
            { file: '.gitignore', weight: 5, name: 'Git ignore file' },
            { file: 'CHANGELOG.md', weight: 8, name: 'Change log' },
            {
                file: 'CONTRIBUTING.md',
                weight: 7,
                name: 'Contribution guidelines',
            },
        ];

        for (const check of checks) {
            if (await this.fileExists(check.file)) {
                results.score += check.weight;
                results.findings.push(`‚úÖ ${check.name} found`);
            } else {
                results.recommendations.push(
                    `Add ${check.name} (${check.file})`
                );
            }
        }
    }

    /**
     * Audit firmware security
     */
    async auditFirmwareSecurity(results) {
        // Check for common security files/patterns
        if (
            (await this.fileExists('src/security.h')) ||
            (await this.fileExists('include/security.h'))
        ) {
            results.findings.push('‚úÖ Security header file found');
        } else {
            results.securityIssues.push('Consider adding security header file');
        }

        if (
            (await this.fileExists('src/crypto.cpp')) ||
            (await this.fileExists('lib/crypto/'))
        ) {
            results.findings.push('‚úÖ Cryptography implementation found');
        } else {
            results.securityIssues.push(
                'Consider adding cryptographic functions'
            );
        }
    }

    /**
     * Audit server documentation
     */
    async auditServerDocumentation(results) {
        if (
            (await this.fileExists('API.md')) ||
            (await this.fileExists('docs/api.md'))
        ) {
            results.findings.push('‚úÖ API documentation found');
        } else {
            results.documentationIssues.push('Add API documentation');
        }
    }

    /**
     * Calculate IoT compliance score
     */
    calculateIoTScore(results) {
        // Base score from file checks (already calculated)
        let score = results.score;

        // Bonus points for security considerations
        if (results.securityIssues.length === 0) {
            score += 10;
        }

        // Bonus points for comprehensive documentation
        if (results.documentationIssues.length === 0) {
            score += 10;
        }

        // Ensure score doesn't exceed 100
        return Math.min(score, 100);
    }

    /**
     * Display IoT audit results
     */
    displayIoTResults(results) {
        console.log(`üìä IoT Compliance Score: ${results.score}/100`);
        console.log(`üéØ Repository Type: ${results.repositoryType}\n`);

        if (results.findings.length > 0) {
            console.log('‚úÖ Compliance Findings:');
            results.findings.forEach((finding) => console.log(`  ${finding}`));
            console.log();
        }

        if (results.recommendations.length > 0) {
            console.log('üí° Recommendations:');
            results.recommendations.forEach((rec) => console.log(`  ‚Ä¢ ${rec}`));
            console.log();
        }

        if (results.securityIssues.length > 0) {
            console.log('üîí Security Recommendations:');
            results.securityIssues.forEach((issue) =>
                console.log(`  ‚Ä¢ ${issue}`)
            );
            console.log();
        }

        if (results.documentationIssues.length > 0) {
            console.log('üìö Documentation Recommendations:');
            results.documentationIssues.forEach((issue) =>
                console.log(`  ‚Ä¢ ${issue}`)
            );
            console.log();
        }
    }

    /**
     * Check if file exists
     */
    async fileExists(filePath) {
        try {
            await fs.access(path.join(process.cwd(), filePath));
            return true;
        } catch {
            return false;
        }
    }

    /**
     * Get package metadata with IoT context
     */
    async getPackageMetadata() {
        try {
            const packagePath = path.join(process.cwd(), 'package.json');
            const packageContent = await fs.readFile(packagePath, 'utf8');
            return JSON.parse(packageContent);
        } catch {
            return null;
        }
    }

    /**
     * Detect repository type for IoT
     */
    detectRepositoryType(packageMetadata) {
        if (!packageMetadata) return 'general';

        const { keywords = [], name = '', description = '' } = packageMetadata;
        const content = [...keywords, name, description]
            .join(' ')
            .toLowerCase();

        // IoT and Embedded Systems Detection
        if (
            content.includes('firmware') ||
            content.includes('embedded') ||
            content.includes('esp32') ||
            content.includes('esp8266') ||
            content.includes('arduino') ||
            content.includes('platformio')
        ) {
            return 'iot-firmware';
        }

        if (
            content.includes('server') &&
            (content.includes('iot') ||
                content.includes('mqtt') ||
                content.includes('sensor'))
        ) {
            return 'iot-server';
        }

        if (content.includes('documentation') && content.includes('iot')) {
            return 'iot-documentation';
        }

        if (content.includes('docker') && content.includes('iot')) {
            return 'iot-infrastructure';
        }

        return 'general';
    }

    /**
     * Generate IoT-specific templates
     */
    async generateIoTTemplate(type) {
        console.log(`üèóÔ∏è  Generating ${type} template...\n`);

        const templates = {
            'iot-firmware': this.generateFirmwareTemplate(),
            'iot-server': this.generateServerTemplate(),
            'iot-documentation': this.generateDocumentationTemplate(),
            'iot-infrastructure': this.generateInfrastructureTemplate(),
        };

        const template = templates[type];
        if (template) {
            console.log(template);
        } else {
            console.log('‚ùå Unknown IoT template type');
        }
    }

    /**
     * Generate firmware template structure
     */
    generateFirmwareTemplate() {
        return `
üìÅ IoT Firmware Project Structure:

‚îú‚îÄ‚îÄ platformio.ini          # PlatformIO configuration
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.cpp            # Main application code
‚îÇ   ‚îú‚îÄ‚îÄ config.h            # Configuration constants
‚îÇ   ‚îú‚îÄ‚îÄ sensors.cpp         # Sensor management
‚îÇ   ‚îú‚îÄ‚îÄ wifi_manager.cpp    # WiFi connectivity
‚îÇ   ‚îú‚îÄ‚îÄ mqtt_client.cpp     # MQTT communication
‚îÇ   ‚îî‚îÄ‚îÄ security.cpp        # Security functions
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îú‚îÄ‚îÄ config.h            # Global configuration
‚îÇ   ‚îú‚îÄ‚îÄ sensors.h           # Sensor definitions
‚îÇ   ‚îî‚îÄ‚îÄ security.h          # Security headers
‚îú‚îÄ‚îÄ lib/                    # Custom libraries
‚îú‚îÄ‚îÄ test/                   # Unit tests
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ HARDWARE.md         # Hardware documentation
‚îÇ   ‚îú‚îÄ‚îÄ API.md              # Communication protocol
‚îÇ   ‚îî‚îÄ‚îÄ SETUP.md            # Setup instructions
‚îú‚îÄ‚îÄ examples/               # Usage examples
‚îú‚îÄ‚îÄ schematics/             # Circuit diagrams
‚îú‚îÄ‚îÄ README.md               # Project documentation
‚îú‚îÄ‚îÄ LICENSE                 # License file
‚îî‚îÄ‚îÄ .gitignore              # Git ignore rules

üîß Recommended platformio.ini:
[env:esp32]
platform = espressif32
board = esp32dev
framework = arduino
monitor_speed = 115200
lib_deps = 
    knolleary/PubSubClient
    bblanchon/ArduinoJson
    me-no-dev/ESPAsyncWebServer
`;
    }

    /**
     * Generate server template structure
     */
    generateServerTemplate() {
        return `
üìÅ IoT Server Project Structure:

‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.py             # Main application
‚îÇ   ‚îú‚îÄ‚îÄ mqtt_handler.py     # MQTT message processing
‚îÇ   ‚îú‚îÄ‚îÄ database.py         # Database operations
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py       # API endpoints
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py         # Authentication
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îÇ       ‚îú‚îÄ‚îÄ sensor.py       # Sensor data models
‚îÇ       ‚îî‚îÄ‚îÄ device.py       # Device models
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ settings.py         # Application settings
‚îÇ   ‚îú‚îÄ‚îÄ mqtt.conf           # MQTT configuration
‚îÇ   ‚îî‚îÄ‚îÄ database.conf       # Database configuration
‚îú‚îÄ‚îÄ tests/                  # Test suite
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ API.md              # API documentation
‚îÇ   ‚îú‚îÄ‚îÄ DEPLOYMENT.md       # Deployment guide
‚îÇ   ‚îî‚îÄ‚îÄ MQTT.md             # MQTT protocol docs
‚îú‚îÄ‚îÄ docker-compose.yml      # Container orchestration
‚îú‚îÄ‚îÄ Dockerfile              # Container definition
‚îú‚îÄ‚îÄ requirements.txt        # Python dependencies
‚îú‚îÄ‚îÄ .env.example            # Environment template
‚îú‚îÄ‚îÄ README.md               # Project documentation
‚îî‚îÄ‚îÄ LICENSE                 # License file

üîß Recommended requirements.txt:
fastapi==0.104.1
uvicorn[standard]==0.24.0
paho-mqtt==1.6.1
influxdb-client==1.38.0
redis==5.0.1
python-dotenv==1.0.0
pydantic==2.5.0
`;
    }

    /**
     * Generate documentation template structure
     */
    generateDocumentationTemplate() {
        return `
üìÅ IoT Documentation Project Structure:

‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ getting-started/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ installation.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quick-start.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requirements.md
‚îÇ   ‚îú‚îÄ‚îÄ hardware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sensor-specs.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wiring-diagrams.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pcb-designs.md
‚îÇ   ‚îú‚îÄ‚îÄ software/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ firmware-guide.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-reference.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ protocols.md
‚îÇ   ‚îú‚îÄ‚îÄ deployment/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cloud-setup.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ local-setup.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ monitoring.md
‚îÇ   ‚îî‚îÄ‚îÄ troubleshooting/
‚îÇ       ‚îú‚îÄ‚îÄ common-issues.md
‚îÇ       ‚îú‚îÄ‚îÄ debugging.md
‚îÇ       ‚îî‚îÄ‚îÄ faq.md
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ basic-sensor/
‚îÇ   ‚îú‚îÄ‚îÄ mqtt-client/
‚îÇ   ‚îî‚îÄ‚îÄ full-system/
‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ diagrams/
‚îÇ   ‚îî‚îÄ‚îÄ videos/
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ build-docs.py
‚îÇ   ‚îî‚îÄ‚îÄ validate-links.py
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îî‚îÄ‚îÄ LICENSE
`;
    }

    /**
     * Generate infrastructure template structure
     */
    generateInfrastructureTemplate() {
        return `
üìÅ IoT Infrastructure Project Structure:

‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.mqtt     # MQTT broker
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.api      # API server
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.ui       # Web interface
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile.worker   # Background workers
‚îú‚îÄ‚îÄ k8s/
‚îÇ   ‚îú‚îÄ‚îÄ namespace.yaml      # Kubernetes namespace
‚îÇ   ‚îú‚îÄ‚îÄ configmap.yaml      # Configuration
‚îÇ   ‚îú‚îÄ‚îÄ secrets.yaml        # Secrets management
‚îÇ   ‚îú‚îÄ‚îÄ mqtt-deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ api-deployment.yaml
‚îÇ   ‚îî‚îÄ‚îÄ ingress.yaml        # Load balancer
‚îú‚îÄ‚îÄ terraform/
‚îÇ   ‚îú‚îÄ‚îÄ main.tf             # Infrastructure definition
‚îÇ   ‚îú‚îÄ‚îÄ variables.tf        # Input variables
‚îÇ   ‚îî‚îÄ‚îÄ outputs.tf          # Output values
‚îú‚îÄ‚îÄ monitoring/
‚îÇ   ‚îú‚îÄ‚îÄ prometheus.yml      # Metrics collection
‚îÇ   ‚îú‚îÄ‚îÄ grafana/            # Dashboards
‚îÇ   ‚îî‚îÄ‚îÄ alerts.yml          # Alert rules
‚îú‚îÄ‚îÄ security/
‚îÇ   ‚îú‚îÄ‚îÄ policies/           # Security policies
‚îÇ   ‚îú‚îÄ‚îÄ certificates/       # SSL certificates
‚îÇ   ‚îî‚îÄ‚îÄ firewall.rules      # Network security
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ deploy.sh           # Deployment script
‚îÇ   ‚îú‚îÄ‚îÄ backup.sh           # Backup script
‚îÇ   ‚îî‚îÄ‚îÄ restore.sh          # Restore script
‚îú‚îÄ‚îÄ docker-compose.yml      # Local development
‚îú‚îÄ‚îÄ docker-compose.prod.yml # Production setup
‚îú‚îÄ‚îÄ README.md               # Setup documentation
‚îî‚îÄ‚îÄ LICENSE                 # License file
`;
    }
}

module.exports = IoTManager;
